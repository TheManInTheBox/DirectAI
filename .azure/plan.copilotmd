# Azure Deployment Plan for DirectAI Music Platform

## **Goal**
Deploy the DirectAI AI Music Platform as a B2C SaaS solution to Azure Container Apps with auto-scaling workers, multi-tenant architecture, and user subscription tiers.

## **Project Information**

**DirectAI Music Platform** - B2C SaaS AI-powered music analysis and generation platform
- **API Service**: .NET 8.0 REST API with Entity Framework, PostgreSQL, SignalR for real-time updates
- **Analysis Worker**: Python FastAPI service with Demucs (stem separation), librosa, essentia, madmom for audio analysis
- **Generation Worker**: Python FastAPI service with MusicGen (Meta AI) for music generation with trained model support
- **Training Worker**: Python FastAPI service with MusicGen LoRA fine-tuning for custom model training
- **Job System**: Async processing with retry logic and status tracking
- **Storage**: Blob storage for audio files (MP3, WAV, stems), trained model checkpoints
- **Database**: PostgreSQL 16 for multi-tenant data (users, subscriptions, jobs, training datasets, models)
- **Queue**: Service Bus for distributing jobs to workers
- **Containerization**: All services containerized with optimized Docker images
- **Multi-Tenancy**: Single shared infrastructure with tenant isolation at database/storage level

## **Azure Resources Architecture**

```mermaid
graph TB
    Users[End Users] --> AppGW[Application Gateway + CDN]
    AppGW --> API[Container App: API]
    
    API --> SB[Service Bus]
    API --> DB[(PostgreSQL Flexible - Multi-tenant)]
    API --> Blob[Blob Storage - Tenant-partitioned]
    
    SB --> AW[Container App: Analysis Worker 0-5 replicas]
    SB --> GW[Container App: Generation Worker 0-3 replicas]
    SB --> TW[Container App: Training Worker 0-2 replicas]
    
    AW --> Blob
    GW --> Blob
    TW --> Blob
    AW --> DB
    GW --> DB
    TW --> DB
    
    API --> ACR[Container Registry]
    AW --> ACR
    GW --> ACR
    TW --> ACR
    
    API --> AI[Application Insights]
    AW --> AI
    GW --> AI
    TW --> AI
    
    API --> MI[Managed Identity]
    AW --> MI
    GW --> MI
    TW --> MI
    
    MI --> KV[Key Vault]
    MI --> Blob
    MI --> DB
    
    API --> Auth[Azure AD B2C]
    Users --> Auth
```

**Data Flow:**
- Container Apps pull images from Azure Container Registry
- API receives requests from clients and enqueues jobs to Service Bus
- Analysis/Generation/Training Workers poll Service Bus for jobs, process audio files from Blob Storage
- All services use Managed Identity to access PostgreSQL, Blob Storage, and Key Vault
- Application Insights collects telemetry from all services

## **Subscription Model & Multi-Tenancy**

This is a **B2C SaaS solution** with:
- **Single Azure subscription** hosting all infrastructure
- **Shared multi-tenant architecture** for cost efficiency
- **Tenant isolation** at database and storage level
- **User subscription tiers** (Free, Pro, Enterprise) with feature/quota limits

### **Tenant Isolation Strategy**

1. **Database Level**:
   - All tables include `UserId` foreign key
   - Row-Level Security policies enforce data isolation
   - Database connection uses single service account with tenant context

2. **Storage Level**:
   - Blob paths prefixed with userId: `{userId}/uploads/{jobId}/track.mp3`
   - Trained models: `{userId}/models/{modelId}/checkpoint.zip`
   - Access controlled via API with user context validation

3. **Resource Limits by Tier**:
   - **Free**: 10 jobs/month, 1GB storage, base models only
   - **Pro**: Unlimited jobs, 50GB storage, trained models, priority queue
   - **Enterprise**: Unlimited everything, dedicated workers, SLA

## **Recommended Azure Resources**

### Application Services

#### **1. API Container App**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with dedicated resources
  - CPU: 1.0 vCPU
  - Memory: 2.0 GiB
  - Min replicas: 1 (always available)
  - Max replicas: 10
  - Scaling: HTTP requests (1 replica per 100 concurrent requests)
- **Configuration**:
  - Language: dotnet
  - Runtime: .NET 8.0
  - DockerFilePath: `src/MusicPlatform.Api/Dockerfile`
  - DockerContext: `.`
  - Target Port: 5000
  - Ingress: External (HTTPS enabled)
  - Environment Variables:
    - `ASPNETCORE_ENVIRONMENT=Production`
    - `ConnectionStrings__DefaultConnection` (from Key Vault)
    - `AzureStorage__ConnectionString` (from Key Vault)
    - `ServiceBus__ConnectionString` (from Key Vault)
    - `ApplicationInsights__ConnectionString` (auto-injected)

#### **2. Analysis Worker Container App**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan
  - CPU: 2.0 vCPU
  - Memory: 4.0 GiB
  - Min replicas: 0 (scale to zero when idle)
  - Max replicas: 5
  - Scaling: Service Bus queue depth (1 replica per 10 messages)
- **Configuration**:
  - Language: python
  - Runtime: Python 3.10
  - DockerFilePath: `workers/analysis/Dockerfile`
  - DockerContext: `workers/analysis`
  - Target Port: 8004
  - Ingress: Internal only
  - Environment Variables:
    - `AZURE_STORAGE_CONNECTION_STRING` (from Key Vault)
    - `BLOB_CONTAINER_NAME=audio-files`
    - `DATABASE_URL` (from Key Vault)

#### **3. Generation Worker Container App**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with optional GPU
  - CPU: 2.0 vCPU
  - Memory: 4.0 GiB
  - GPU: Optional (T4 for faster generation)
  - Min replicas: 0 (scale to zero when idle)
  - Max replicas: 3
  - Scaling: Service Bus queue depth (1 replica per 5 messages)
- **Configuration**:
  - Language: python
  - Runtime: Python 3.10
  - DockerFilePath: `workers/generation/Dockerfile`
  - DockerContext: `workers/generation`
  - Target Port: 8080
  - Ingress: Internal only
  - Environment Variables:
    - `AZURE_STORAGE_CONNECTION_STRING` (from Key Vault)
    - `BLOB_CONTAINER_NAME=audio-files`
    - `DATABASE_URL` (from Key Vault)
    - `USE_GPU=false` (set true for GPU)

#### **4. Training Worker Container App**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with optional GPU (highly recommended)
  - CPU: 4.0 vCPU
  - Memory: 8.0 GiB
  - GPU: Optional (A100 for fast training, T4 for budget)
  - Min replicas: 0 (scale to zero when idle)
  - Max replicas: 2 (training is compute-intensive)
  - Scaling: Service Bus queue depth (1 replica per 2 messages)
- **Configuration**:
  - Language: python
  - Runtime: Python 3.10
  - DockerFilePath: `workers/training/Dockerfile` (CPU) or `Dockerfile.gpu` (GPU)
  - DockerContext: `workers/training`
  - Target Port: 8003
  - Ingress: Internal only
  - Environment Variables:
    - `AZURE_STORAGE_CONNECTION_STRING` (from Key Vault)
    - `BLOB_CONTAINER_NAME=audio-files`
    - `DATABASE_URL` (from Key Vault)
    - `USE_GPU=true` (recommended for training)
    - `TRAINING_WORKER_URL=http://training-worker:8003`

### Dependency Resources

#### **PostgreSQL Flexible Server** - Multi-tenant database
- **SKU**: Burstable B2s (2 vCPU, 4 GiB RAM) - start small, scale to General Purpose GP_Standard_D4s_v3 (4 vCPU, 16 GiB) as needed
- **Service Type**: Azure Database for PostgreSQL Flexible Server
- **Storage**: 32 GB (auto-grow enabled, max 1 TB)
- **Backup**: 7-day retention (configurable to 35 days for production)
- **Connection Type**: Managed Identity + Password (stored in Key Vault)
- **Configuration**:
  - PostgreSQL Version: 16
  - High Availability: Disabled for dev/test, Zone-redundant for production
  - SSL: Required
  - **Row-Level Security**: Enabled for tenant isolation
    - Users table has UserId as primary tenant identifier
    - All tables with user data include UserId foreign key
    - Policies enforce `WHERE UserId = current_setting('app.user_id')`
  - Firewall: Allow Azure services + VNet integration
  - SSL: Required
- **Environment Variables**:
  - `DATABASE_URL` (connection string with managed identity)

#### **Blob Storage Account** - Multi-tenant with path-based isolation
- **SKU**: Standard LRS (Standard_LRS) - upgrade to GRS for production
- **Service Type**: Azure Blob Storage
- **Performance**: Standard (Hot tier for active files, Cool tier for archives)
- **Connection Type**: Managed Identity (DefaultAzureCredential)
- **Configuration**:
  - Account Kind: StorageV2
  - Replication: Locally-redundant (LRS) for dev, Geo-redundant (GRS) for prod
  - Containers: `audio-files` (with user-based blob prefixes)
  - **Path Structure**:
    - User uploads: `{userId}/uploads/{jobId}/track.mp3`
    - User stems: `{userId}/stems/{stemId}/bass.wav`
    - Trained models: `{userId}/models/{modelId}/checkpoint.zip`
  - Lifecycle Policy: Move to Cool tier after 30 days, Archive after 180 days
  - **Access Control**: API validates userId in path matches authenticated user
- **Environment Variables**:
  - `AZURE_STORAGE_ACCOUNT_NAME`
  - `BLOB_CONTAINER_NAME=audio-files`

#### **Service Bus Namespace** - Shared queue with message priority
- **SKU**: Standard tier
- **Service Type**: Azure Service Bus
- **Connection Type**: Managed Identity
- **Configuration**:
  - Queues: `analysis-jobs`, `generation-jobs`, `training-jobs`
  - Max Queue Size: 5 GB per queue
  - Message TTL: 14 days
  - Dead Letter Queue: Enabled
  - Lock Duration: 5 minutes
  - **Message Properties**: Include userId, subscriptionTier (for priority routing)
- **Environment Variables**:
  - `SERVICE_BUS_NAMESPACE`
  - `ANALYSIS_QUEUE_NAME=analysis-jobs`
  - `GENERATION_QUEUE_NAME=generation-jobs`
  - `TRAINING_QUEUE_NAME=training-jobs`

### Recommended Supporting Services

#### **Container Registry**
- **SKU**: Basic tier (upgrade to Standard for geo-replication)
- **Configuration**:
  - Admin User: Disabled
  - Anonymous Pull: Disabled
  - Managed Identity: Required for Container Apps to pull images

#### **Application Insights**
- **Service Type**: Application Insights
- **Configuration**:
  - Connected to Log Analytics Workspace
  - Smart Detection: Enabled
  - Continuous Export: To Blob Storage (optional)
  - Retention: 90 days

#### **Log Analytics Workspace**
- **Service Type**: Log Analytics
- **Configuration**:
  - All Container Apps send logs here
  - Retention: 30 days (free tier), 90+ days (paid)
  - Diagnostic Settings: Enabled for all resources

#### **Key Vault** - Multi-tenant secrets management
- **SKU**: Standard tier
- **Service Type**: Azure Key Vault
- **Configuration**:
  - Secrets: Database connection strings, Storage connection strings, Service Bus keys
  - Access Policy: Managed Identity has Get/List permissions
  - Soft Delete: Enabled (90 days retention)
  - Purge Protection: Enabled
- **Secrets**:
  - `DatabaseConnectionString`
  - `StorageConnectionString`
  - `ServiceBusConnectionString`
  - `AzureAdB2C--ClientSecret` (for user authentication)

#### **Azure AD B2C** - User authentication and subscription management
- **Service Type**: Azure Active Directory B2C
- **Configuration**:
  - User flows: Sign up/sign in, password reset
  - Custom attributes: SubscriptionTier (Free/Pro/Enterprise), QuotaRemaining
  - Token claims: userId, email, subscriptionTier
  - API scopes: user.read, jobs.write, models.train
- **Integration**:
  - API validates JWT tokens from Azure AD B2C
  - User identity stored in Users table (synced on first login)
  - Subscription tier determines resource limits and priority

### Recommended Security Configurations

#### **Managed Identity** - Service-to-service authentication
- **Type**: User-assigned Managed Identity
- **Assigned To**: All Container Apps (API, Analysis Worker, Generation Worker, Training Worker)
- **Role Assignments**:
  - `AcrPull` role on Container Registry
  - `Storage Blob Data Contributor` on Blob Storage account
  - `Azure Service Bus Data Receiver` and `Azure Service Bus Data Sender` on Service Bus namespace
  - `Key Vault Secrets User` on Key Vault

#### **Network Security**
- **Container Apps Environment**: VNet integration (recommended for production)
- **PostgreSQL**: Firewall rules to allow Container Apps subnet only (or Azure services for dev)
- **Blob Storage**: Firewall rules to allow Container Apps subnet only (or Azure services for dev)
- **API Ingress**: External HTTPS with custom domain + managed certificate
- **Workers Ingress**: Internal only (not accessible from internet)

#### **SSL/TLS**
- **API**: HTTPS enforced, custom domain with managed certificate
- **PostgreSQL**: SSL required
- **Storage**: HTTPS only

#### **Multi-Tenant Security**
- **Database**: Row-Level Security enforces userId-based isolation
- **Storage**: API validates blob paths contain authenticated user's userId
- **Queue**: Workers validate message userId matches job owner
- **Rate Limiting**: Per-user quotas enforced at API level (based on subscription tier)
- **Cost Tracking**: Tag all resources with cost center, track per-user usage in database

## **Execution Steps**

> **Below are the steps for deployment; ask Copilot to update or execute this plan.**

### **1. Provision Azure Infrastructure And Deploy the Application**

1. **Get IaC Rules**: Use `iac-rules-get` tool to retrieve best practices for Container Apps, PostgreSQL, Storage, Service Bus

2. **Generate Bicep Files**: Create infrastructure-as-code files in `infrastructure/` directory:
   - `main.bicep` - Main orchestration file
   - `containerApps.bicep` - Container Apps environment and apps
   - `database.bicep` - PostgreSQL Flexible Server
   - `storage.bicep` - Blob Storage account
   - `serviceBus.bicep` - Service Bus namespace and queues
   - `monitoring.bicep` - Application Insights and Log Analytics
   - `security.bicep` - Managed Identity, Key Vault, Role Assignments
   - `main.parameters.json` - Environment-specific parameters

3. **Pre-check**: Use `get_errors` tool to validate Bicep syntax and fix any issues

4. **Initialize AZD**: 
   ```powershell
   azd init
   # Select template: Empty template
   # Configure azure.yaml with services
   ```

5. **Preview Deployment**:
   ```powershell
   azd provision --preview
   # Review resources to be created
   ```

6. **Deploy Infrastructure and Apps**:
   ```powershell
   azd up
   # This will:
   # - Build Docker images
   # - Push to Container Registry
   # - Provision all Azure resources
   # - Deploy container apps
   ```

7. **Verify Deployment**:
   ```powershell
   azd show
   # Check resource group in Azure Portal
   ```

8. **Check Application Logs**:
   ```powershell
   # Use azd-app-log-get tool to check logs
   azd monitor --logs
   ```

### **2. Post-Deployment Configuration**

1. **Database Migration**:
   ```powershell
   # Connect to Azure PostgreSQL and run migrations
   azd exec api -- dotnet ef database update --connection "$DATABASE_URL"
   ```

2. **Enable Row-Level Security**:
   ```sql
   -- Connect to PostgreSQL
   ALTER TABLE "Jobs" ENABLE ROW LEVEL SECURITY;
   ALTER TABLE "Stems" ENABLE ROW LEVEL SECURITY;
   ALTER TABLE "TrainingDatasets" ENABLE ROW LEVEL SECURITY;
   ALTER TABLE "TrainedModels" ENABLE ROW LEVEL SECURITY;
   
   -- Create RLS policies (example for Jobs)
   CREATE POLICY jobs_isolation ON "Jobs"
     USING ("UserId" = current_setting('app.user_id')::uuid);
   ```

3. **Test API Endpoint**:
   ```powershell
   $apiUrl = azd show --output json | ConvertFrom-Json | Select-Object -ExpandProperty services | Where-Object {$_.name -eq 'api'} | Select-Object -ExpandProperty endpoint
   curl "$apiUrl/health"
   ```

4. **Verify Workers**:
   - Check Service Bus queues in Azure Portal (3 queues: analysis, generation, training)
   - Submit test analysis job via API
   - Monitor Container Apps scaling metrics (should scale to 0 when idle)

5. **Configure Azure AD B2C**:
   - Create user flows for sign-up/sign-in
   - Configure API permissions and scopes
   - Add custom user attributes (SubscriptionTier)
   - Test authentication flow with MAUI app

### **3. Summary**

1. Generate deployment summary and save to `.azure/summary.copilotmd`
2. Document all created resources with resource IDs
3. Create architecture diagram showing deployed components
4. List environment variables and configuration
5. Provide user onboarding guide for B2C SaaS

## **B2C SaaS Operational Model**

### **User Subscription Management**

**Subscription Tiers**:
- **Free**: $0/month
  - 10 jobs/month (5 analysis + 5 generation)
  - 1 GB storage
  - Base MusicGen models only (no training)
  - Community support
  
- **Pro**: $29/month
  - Unlimited jobs
  - 50 GB storage
  - Trained model support (up to 5 models)
  - Priority queue processing
  - Email support
  
- **Enterprise**: $299/month
  - Unlimited everything
  - Dedicated worker instances (no sharing)
  - Unlimited trained models
  - 99.9% SLA
  - Phone + chat support

**Billing Integration**:
- Stripe or Azure Marketplace for subscription payments
- Usage metering: Track jobs/month per user in database
- Quota enforcement: API checks user's remaining quota before queuing jobs
- Auto-upgrade prompts: When user hits free tier limits

### **Monitoring Multi-Tenant Platform**

- **User Dashboard**: Azure Portal workbook showing active users, jobs/hour, storage usage
- **Cost Tracking**: Tag resources, track per-user costs in database (storage bytes, compute minutes)
- **Performance Metrics**: Application Insights monitors:
  - API response times (p50, p95, p99)
  - Worker processing times (per job type)
  - Queue depths (alert if > 100 messages)
  - Error rates (alert if > 1% failed jobs)
- **Security Monitoring**: Failed login attempts, abnormal data access patterns

### **Scaling Strategy**

**Auto-Scaling Rules**:
- API: Scale on HTTP requests (1 replica per 100 concurrent)
- Analysis Worker: Scale on Service Bus queue depth (1 replica per 10 messages, max 5)
- Generation Worker: Scale on queue depth (1 replica per 5 messages, max 3)
- Training Worker: Scale on queue depth (1 replica per 2 messages, max 2)

**Cost Optimization**:
- Workers scale to zero when idle (consumption plan)
- Cool storage tier after 30 days (reduce storage costs by 50%)
- Database: Start with Burstable B2s (~$25/month), scale to GP as needed
- GPU workers: Only for Enterprise tier (on-demand provisioning)

## **Pricing Model for End Users**

**Subscription Revenue**:
- Free tier: Lead generation, convert to paid
- Pro tier: $29/month × 1,000 users = $29,000/month
- Enterprise tier: $299/month × 50 users = $14,950/month
- **Total MRR**: ~$44,000/month at 1,050 paid users

**Infrastructure Costs** (estimated):
- PostgreSQL Flexible (B2s): $25/month
- Blob Storage (500 GB): $10/month
- Service Bus (Standard): $10/month
- Container Apps (API + workers): $200-500/month (usage-based)
- Application Insights: $50/month
- Container Registry: $5/month
- Key Vault: $3/month
- **Total**: ~$300-600/month for shared infrastructure

**Gross Margin**: ~98% (infrastructure costs << subscription revenue)

## **Next Steps for Deployment**

1. **Review this plan** - Ensure B2C multi-tenant architecture meets requirements
2. **Get Azure best practices** - Call `get_bestpractices` tool for Container Apps, PostgreSQL, Service Bus
3. **Generate Bicep templates** - Create infrastructure-as-code in `infrastructure/` directory
4. **Configure azd** - Set up `azure.yaml` with 4 services (api, analysis-worker, generation-worker, training-worker)
5. **Deploy** - Run `azd up` to provision infrastructure and deploy containers
6. **Configure security** - Enable Row-Level Security, set up Azure AD B2C
7. **Test end-to-end** - Upload track → analyze → train model → generate music
8. **Monitor** - Set up Application Insights dashboards, alerts, cost tracking

Ready to proceed with deployment?

**Azure Infrastructure** (customer pays directly or you resell with 25% markup):
- Estimated $200-500/month for small-medium usage
- Scales with actual usage (workers scale to zero when idle)

**Optional Add-ons**:
- GPU workers: +$300/month
- 24/7 support: +$500/month
- Custom features: Project-based pricing
