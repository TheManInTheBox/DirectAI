# Azure Deployment Plan for DirectAI Music Platform

## **Goal**
Deploy the DirectAI AI Music Platform to Azure Container Apps with auto-scaling workers, enabling per-customer isolated deployments in separate Azure subscriptions.

## **Project Information**

**DirectAI Music Platform** - AI-powered music analysis and generation platform
- **API Service**: .NET 8.0 REST API with Entity Framework, PostgreSQL, SignalR for real-time updates
- **Analysis Worker**: Python FastAPI service with Demucs (stem separation), librosa, essentia, madmom for audio analysis
- **Generation Worker**: Python FastAPI service with MusicGen (Meta AI) for music generation
- **Job System**: Async processing with retry logic and status tracking
- **Storage**: Blob storage for audio files (MP3, WAV, stems)
- **Database**: PostgreSQL 16 for job tracking, metadata, and user data
- **Queue**: Service Bus for distributing jobs to workers
- **Containerization**: All services containerized with optimized Docker images

## **Azure Resources Architecture**

```mermaid
graph TB
    Client[Client/MAUI App] --> AppGW[Application Gateway]
    AppGW --> API[Container App: API]
    
    API --> SB[Service Bus]
    API --> DB[(PostgreSQL Flexible)]
    API --> Blob[Blob Storage]
    
    SB --> AW[Container App: Analysis Worker]
    SB --> GW[Container App: Generation Worker]
    
    AW --> Blob
    GW --> Blob
    AW --> DB
    GW --> DB
    
    API --> ACR[Container Registry]
    AW --> ACR
    GW --> ACR
    
    API --> AI[Application Insights]
    AW --> AI
    GW --> AI
    
    API --> MI[Managed Identity]
    AW --> MI
    GW --> MI
    
    MI --> KV[Key Vault]
    MI --> Blob
    MI --> DB
```

**Data Flow:**
- Container Apps pull images from Azure Container Registry
- API receives requests from clients and enqueues jobs to Service Bus
- Analysis Worker polls Service Bus for analysis jobs, processes audio files from Blob Storage
- Generation Worker polls Service Bus for generation jobs, creates audio files to Blob Storage
- All services use Managed Identity to access PostgreSQL, Blob Storage, and Key Vault
- Application Insights collects telemetry from all services

## **Recommended Azure Resources**

### Application Services

#### **1. API Container App**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with dedicated resources
  - CPU: 1.0 vCPU
  - Memory: 2.0 GiB
  - Min replicas: 1 (always available)
  - Max replicas: 10
- **Configuration**:
  - Language: dotnet
  - Runtime: .NET 8.0
  - DockerFilePath: `src/MusicPlatform.Api/Dockerfile`
  - DockerContext: `.`
  - Target Port: 5000
  - Ingress: External (HTTPS enabled)
  - Environment Variables:
    - `ASPNETCORE_ENVIRONMENT=Production`
    - `ConnectionStrings__DefaultConnection` (from Key Vault)
    - `AzureStorage__ConnectionString` (from Key Vault)
    - `ServiceBus__ConnectionString` (from Key Vault)
    - `ApplicationInsights__ConnectionString` (auto-injected)

#### **2. Analysis Worker Container App**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with GPU support (optional)
  - CPU: 2.0 vCPU
  - Memory: 4.0 GiB
  - Min replicas: 0 (scale to zero when idle)
  - Max replicas: 5
  - Scaling: Based on Service Bus queue depth (1 replica per 10 messages)
- **Configuration**:
  - Language: python
  - Runtime: Python 3.10
  - DockerFilePath: `workers/analysis/Dockerfile`
  - DockerContext: `workers/analysis`
  - Target Port: 8001
  - Ingress: Internal only
  - Environment Variables:
    - `AZURE_STORAGE_CONNECTION_STRING` (from Key Vault)
    - `BLOB_CONTAINER_NAME=audio-files`
    - `DATABASE_URL` (from Key Vault)
    - `USE_GPU=false` (set true for GPU SKU)

#### **3. Generation Worker Container App**
- **Hosting Service Type**: Azure Container Apps
- **SKU**: Consumption plan with GPU support (recommended for production)
  - CPU: 2.0 vCPU
  - Memory: 4.0 GiB
  - GPU: Optional (T4 or A100 for faster generation)
  - Min replicas: 0 (scale to zero when idle)
  - Max replicas: 3
  - Scaling: Based on Service Bus queue depth (1 replica per 5 messages)
- **Configuration**:
  - Language: python
  - Runtime: Python 3.10
  - DockerFilePath: `workers/generation/Dockerfile`
  - DockerContext: `workers/generation`
  - Target Port: 8080
  - Ingress: Internal only
  - Environment Variables:
    - `AZURE_STORAGE_CONNECTION_STRING` (from Key Vault)
    - `BLOB_CONTAINER_NAME=audio-files`
    - `USE_GPU=false` (set true for GPU SKU)

### Dependency Resources

#### **PostgreSQL Flexible Server**
- **SKU**: Burstable B2s (2 vCPU, 4 GiB RAM) - scalable to General Purpose
- **Service Type**: Azure Database for PostgreSQL Flexible Server
- **Storage**: 32 GB (auto-grow enabled, max 256 GB)
- **Backup**: 7-day retention (configurable to 35 days)
- **Connection Type**: Managed Identity + Password (stored in Key Vault)
- **Configuration**:
  - PostgreSQL Version: 16
  - High Availability: Disabled for dev/test, Zone-redundant for production
  - Firewall: Allow Azure services
  - SSL: Required
- **Environment Variables**:
  - `DATABASE_URL` (connection string with managed identity)

#### **Blob Storage Account**
- **SKU**: Standard LRS (Standard_LRS)
- **Service Type**: Azure Blob Storage
- **Performance**: Standard (Hot tier for active files, Cool tier for archives)
- **Connection Type**: Managed Identity (DefaultAzureCredential)
- **Configuration**:
  - Account Kind: StorageV2
  - Replication: Locally-redundant (LRS) for dev, Geo-redundant (GRS) for prod
  - Containers: `audio-files`, `stems`, `training-data`
  - Lifecycle Policy: Move to Cool tier after 30 days, Archive after 180 days
- **Environment Variables**:
  - `AZURE_STORAGE_ACCOUNT_NAME`
  - `BLOB_CONTAINER_NAME=audio-files`

#### **Service Bus Namespace**
- **SKU**: Standard tier
- **Service Type**: Azure Service Bus
- **Connection Type**: Managed Identity
- **Configuration**:
  - Queues: `analysis-jobs`, `generation-jobs`
  - Max Queue Size: 5 GB
  - Message TTL: 14 days
  - Dead Letter Queue: Enabled
  - Lock Duration: 5 minutes
- **Environment Variables**:
  - `SERVICE_BUS_NAMESPACE`
  - `ANALYSIS_QUEUE_NAME=analysis-jobs`
  - `GENERATION_QUEUE_NAME=generation-jobs`

### Recommended Supporting Services

#### **Container Registry**
- **SKU**: Basic tier (upgrade to Standard for geo-replication)
- **Configuration**:
  - Admin User: Disabled
  - Anonymous Pull: Disabled
  - Managed Identity: Required for Container Apps to pull images

#### **Application Insights**
- **Service Type**: Application Insights
- **Configuration**:
  - Connected to Log Analytics Workspace
  - Smart Detection: Enabled
  - Continuous Export: To Blob Storage (optional)
  - Retention: 90 days

#### **Log Analytics Workspace**
- **Service Type**: Log Analytics
- **Configuration**:
  - All Container Apps send logs here
  - Retention: 30 days (free tier), 90+ days (paid)
  - Diagnostic Settings: Enabled for all resources

#### **Key Vault**
- **SKU**: Standard tier
- **Service Type**: Azure Key Vault
- **Configuration**:
  - Secrets: Database connection strings, Storage connection strings, Service Bus keys
  - Access Policy: Managed Identity has Get/List permissions
  - Soft Delete: Enabled (90 days retention)
  - Purge Protection: Enabled
- **Secrets**:
  - `DatabaseConnectionString`
  - `StorageConnectionString`
  - `ServiceBusConnectionString`

### Recommended Security Configurations

#### **Managed Identity**
- **Type**: User-assigned Managed Identity
- **Assigned To**: All Container Apps (API, Analysis Worker, Generation Worker)
- **Role Assignments**:
  - `AcrPull` role (7f951dda-4ed3-4680-a7ca-43fe172d538d) on Container Registry
  - `Storage Blob Data Contributor` on Blob Storage account
  - `Azure Service Bus Data Receiver` on Service Bus namespace
  - `Key Vault Secrets User` on Key Vault

#### **Network Security**
- **Container Apps Environment**: Internal VNet integration (optional for enterprise)
- **PostgreSQL**: Firewall rules to allow Container Apps subnet only
- **Blob Storage**: Firewall rules to allow Container Apps subnet only
- **API Ingress**: External HTTPS with custom domain (optional)
- **Workers Ingress**: Internal only (not accessible from internet)

#### **SSL/TLS**
- **API**: HTTPS enforced, custom domain with managed certificate
- **PostgreSQL**: SSL required
- **Storage**: HTTPS only

## **Execution Steps**

> **Below are the steps for deployment; ask Copilot to update or execute this plan.**

### **1. Provision Azure Infrastructure And Deploy the Application**

1. **Get IaC Rules**: Use `iac-rules-get` tool to retrieve best practices for Container Apps, PostgreSQL, Storage, Service Bus

2. **Generate Bicep Files**: Create infrastructure-as-code files in `infrastructure/` directory:
   - `main.bicep` - Main orchestration file
   - `containerApps.bicep` - Container Apps environment and apps
   - `database.bicep` - PostgreSQL Flexible Server
   - `storage.bicep` - Blob Storage account
   - `serviceBus.bicep` - Service Bus namespace and queues
   - `monitoring.bicep` - Application Insights and Log Analytics
   - `security.bicep` - Managed Identity, Key Vault, Role Assignments
   - `main.parameters.json` - Environment-specific parameters

3. **Pre-check**: Use `get_errors` tool to validate Bicep syntax and fix any issues

4. **Initialize AZD**: 
   ```powershell
   azd init
   # Select template: Empty template
   # Configure azure.yaml with services
   ```

5. **Preview Deployment**:
   ```powershell
   azd provision --preview
   # Review resources to be created
   ```

6. **Deploy Infrastructure and Apps**:
   ```powershell
   azd up
   # This will:
   # - Build Docker images
   # - Push to Container Registry
   # - Provision all Azure resources
   # - Deploy container apps
   ```

7. **Verify Deployment**:
   ```powershell
   azd show
   # Check resource group in Azure Portal
   ```

8. **Check Application Logs**:
   ```powershell
   # Use azd-app-log-get tool to check logs
   azd monitor --logs
   ```

### **2. Post-Deployment Configuration**

1. **Database Migration**:
   ```powershell
   # Run Entity Framework migrations
   azd exec api -- dotnet ef database update
   ```

2. **Test API Endpoint**:
   ```powershell
   $apiUrl = azd show --output json | ConvertFrom-Json | Select-Object -ExpandProperty services | Where-Object {$_.name -eq 'api'} | Select-Object -ExpandProperty endpoint
   curl "$apiUrl/health"
   ```

3. **Verify Workers**:
   - Check Service Bus queues in Azure Portal
   - Submit test analysis job via API
   - Monitor Container Apps scaling metrics

### **3. Summary**

1. Generate deployment summary and save to `.azure/summary.copilotmd`
2. Document all created resources with resource IDs
3. Create architecture diagram showing deployed components
4. List environment variables and configuration
5. Provide customer onboarding checklist

## **Per-Customer Deployment Strategy**

### **Automated Customer Onboarding**

1. **Customer Creates Azure Subscription** (or you create under CSP program)

2. **Run Deployment Script** with customer-specific parameters:
   ```powershell
   # Set customer context
   azd env new customer-acme-music
   azd env set CUSTOMER_NAME "acme-music"
   azd env set AZURE_SUBSCRIPTION_ID "customer-sub-id"
   
   # Deploy to their subscription
   azd up --subscription "customer-sub-id"
   ```

3. **Configure Customer-Specific Settings**:
   - Custom domain (e.g., `acme-music.directai.app`)
   - Logo and branding in API
   - Usage limits and quotas
   - Monitoring alerts to your ops team

4. **Provide Customer Access**:
   - Owner/Contributor role on their resource group
   - Application URL and credentials
   - Documentation and support portal

### **Monitoring Multi-Customer Deployments**

- **Centralized Dashboard**: Azure Lighthouse to monitor all customer subscriptions
- **Cost Tracking**: Tag all resources with customer ID
- **Automated Alerts**: Platform health, usage spikes, security issues
- **Update Pipeline**: GitOps to push updates to all customers simultaneously

## **Pricing Model for Customers**

**Setup Fee**: $3,000 (one-time)
- Includes deployment, configuration, training

**Monthly License**: $800-1,500/month
- Platform license and updates
- 8x5 support

**Azure Infrastructure** (customer pays directly or you resell with 25% markup):
- Estimated $200-500/month for small-medium usage
- Scales with actual usage (workers scale to zero when idle)

**Optional Add-ons**:
- GPU workers: +$300/month
- 24/7 support: +$500/month
- Custom features: Project-based pricing
